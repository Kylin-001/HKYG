# 黑科易购项目安全加固和性能优化方案

## 1. 当前安全状况分析

### 1.1 现有安全措施概述

#### 1.1.1 认证与授权
- **Spring Security**: 项目已集成Spring Security框架，实现了基础的认证和授权功能
- **JWT认证**: 采用JWT (JSON Web Token) 进行无状态身份验证，支持Token生成、验证和刷新
- **密码加密**: 使用BCrypt算法进行密码加密存储
- **权限控制**: 实现了基于角色和权限的访问控制机制

#### 1.1.2 API安全
- **CORS配置**: 配置了跨域资源共享策略，允许所有来源的跨域请求
- **CSRF防护**: 禁用了CSRF保护（在JWT认证模式下通常不需要）
- **无状态会话**: 使用SessionCreationPolicy.STATELESS模式，不依赖服务器端会话

#### 1.1.3 请求拦截与监控
- **请求日志拦截器**: 实现了RequestLogInterceptor，记录请求信息、响应时间和异常
- **敏感信息过滤**: 对请求参数中的敏感信息进行脱敏处理
- **请求ID追踪**: 为每个请求生成唯一ID，便于问题追踪

#### 1.1.4 异常处理
- **全局异常处理器**: 实现了GlobalExceptionHandler，统一处理各类异常
- **权限异常处理**: 针对权限不足、用户锁定等异常有专门处理

### 1.2 安全风险评估

#### 1.2.1 高风险项
- **JWT密钥管理**: JWT密钥直接硬编码在配置文件中，存在泄露风险
- **无速率限制**: 缺少API请求速率限制，容易遭受暴力破解和DDoS攻击
- **Token失效机制不完善**: Token失效后只是简单存储在内存中，分布式环境下存在问题
- **CORS配置过宽**: 允许所有来源访问，存在跨域安全风险

#### 1.2.2 中风险项
- **缺少输入验证**: 对API输入参数的验证不够严格
- **异常处理暴露信息**: 部分异常处理可能暴露系统内部信息
- **缺少API访问审计**: 缺乏详细的API访问审计日志
- **缺少XSS防护**: 未明确配置XSS防护措施

#### 1.2.3 低风险项
- **缺少安全响应头**: 未配置安全相关的HTTP响应头
- **密码策略简单**: 缺少密码复杂度验证和定期更换策略
- **缺少多因素认证**: 未实现多因素认证机制

## 2. 安全加固建议

### 2.1 认证与授权增强

#### 2.1.1 JWT安全增强
```java
// 优化后的JWT生成代码示例
@Service
public class EnhancedJwtTokenServiceImpl implements TokenService {
    
    @Value("${security.jwt.secret}")
    private String jwtSecret; // 从环境变量或密钥管理服务获取
    
    @Value("${security.jwt.expiration}")
    private long expiration;  // 短期有效期，如15分钟
    
    @Value("${security.jwt.refresh-expiration}")
    private long refreshExpiration; // 刷新token有效期，如7天
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    // 使用更安全的签名算法
    private SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS512;
    
    @Override
    public String createToken(UserDetails userDetails) {
        // 生成唯一jti (JWT ID)
        String jti = UUID.randomUUID().toString();
        
        // 设置token主体信息
        Claims claims = Jwts.claims().setSubject(userDetails.getUsername());
        claims.put("jti", jti);
        claims.put("roles", userDetails.getAuthorities().stream()
                .map(GrantedAuthority::getAuthority).collect(Collectors.toList()));
        claims.put("created", new Date());
        
        // 创建token
        String token = Jwts.builder()
                .setClaims(claims)
                .setExpiration(generateExpirationDate())
                .signWith(signatureAlgorithm, jwtSecret)
                .compact();
        
        // 存储token信息到Redis，便于后续管理
        String tokenKey = "token:" + userDetails.getUsername() + ":" + jti;
        redisTemplate.opsForValue().set(tokenKey, token, expiration, TimeUnit.MILLISECONDS);
        
        return token;
    }
    
    @Override
    public void invalidateToken(String token) {
        try {
            Claims claims = getClaimsFromToken(token);
            String username = claims.getSubject();
            String jti = claims.get("jti", String.class);
            
            // 从Redis中删除token
            String tokenKey = "token:" + username + ":" + jti;
            redisTemplate.delete(tokenKey);
            
            // 将token加入黑名单，直到过期
            long expireTime = claims.getExpiration().getTime() - System.currentTimeMillis();
            if (expireTime > 0) {
                redisTemplate.opsForValue().set("blacklist:" + token, "1", expireTime, TimeUnit.MILLISECONDS);
            }
        } catch (Exception e) {
            // 处理token解析异常
        }
    }
}
```

#### 2.1.2 实现多因素认证
```java
@Service
public class MultiFactorAuthService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    // 生成验证码
    public String generateVerificationCode(String username) {
        String code = String.format("%06d", new Random().nextInt(999999));
        String key = "mfa:" + username;
        redisTemplate.opsForValue().set(key, code, 5, TimeUnit.MINUTES); // 5分钟有效期
        return code;
    }
    
    // 验证验证码
    public boolean verifyCode(String username, String code) {
        String key = "mfa:" + username;
        String storedCode = (String) redisTemplate.opsForValue().get(key);
        if (storedCode != null && storedCode.equals(code)) {
            redisTemplate.delete(key); // 验证成功后删除
            return true;
        }
        return false;
    }
}
```

### 2.2 API安全增强

#### 2.2.1 实现API速率限制
```java
@Configuration
public class RateLimiterConfig {
    
    @Bean
    public RateLimiter rateLimiter() {
        // 创建基于令牌桶的限流器，每秒生成10个令牌
        return RateLimiter.create(10.0);
    }
}

@Component
public class RateLimitInterceptor implements HandlerInterceptor {
    
    @Autowired
    private RateLimiter rateLimiter;
    
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 检查是否超过速率限制
        if (!rateLimiter.tryAcquire()) {
            response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());
            response.setContentType(MediaType.APPLICATION_JSON_VALUE);
            response.getWriter().write("{\"code\":429,\"message\":\"请求过于频繁，请稍后再试\"}");
            return false;
        }
        return true;
    }
}
```

#### 2.2.2 优化CORS配置
```java
@Configuration
public class CorsConfig implements WebMvcConfigurer {
    
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        // 更严格的CORS配置
        registry.addMapping("/api/**")
                .allowedOrigins("https://app.heikeji.com", "https://admin.heikeji.com") // 明确允许的域名
                .allowedMethods("GET", "POST", "PUT", "DELETE") // 限制允许的HTTP方法
                .allowedHeaders("Authorization", "Content-Type", "X-Requested-With") // 限制允许的请求头
                .allowCredentials(true) // 允许携带凭证
                .maxAge(3600); // 预检请求结果缓存时间
    }
}
```

#### 2.2.3 添加安全响应头
```java
@Component
public class SecurityHeaderFilter extends OncePerRequestFilter {
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        // 添加安全相关的HTTP响应头
        response.setHeader("X-Content-Type-Options", "nosniff");
        response.setHeader("X-Frame-Options", "DENY");
        response.setHeader("X-XSS-Protection", "1; mode=block");
        response.setHeader("Content-Security-Policy", "default-src 'self'");
        response.setHeader("Strict-Transport-Security", "max-age=31536000; includeSubDomains");
        response.setHeader("Referrer-Policy", "strict-origin-when-cross-origin");
        
        filterChain.doFilter(request, response);
    }
}
```

### 2.3 数据安全增强

#### 2.3.1 敏感数据加密
```java
@Service
public class SensitiveDataService {
    
    // 使用AES加密敏感数据
    private final String AES_SECRET_KEY = "your-secure-key-here"; // 从环境变量或密钥管理服务获取
    private final String AES_IV = "your-secure-iv-here"; // 初始化向量
    
    // 加密手机号
    public String encryptPhone(String phone) {
        try {
            SecretKeySpec keySpec = new SecretKeySpec(AES_SECRET_KEY.getBytes(), "AES");
            IvParameterSpec ivSpec = new IvParameterSpec(AES_IV.getBytes());
            
            Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
            cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);
            
            byte[] encrypted = cipher.doFinal(phone.getBytes(StandardCharsets.UTF_8));
            return Base64.getEncoder().encodeToString(encrypted);
        } catch (Exception e) {
            throw new RuntimeException("加密失败", e);
        }
    }
    
    // 解密手机号
    public String decryptPhone(String encryptedPhone) {
        try {
            SecretKeySpec keySpec = new SecretKeySpec(AES_SECRET_KEY.getBytes(), "AES");
            IvParameterSpec ivSpec = new IvParameterSpec(AES_IV.getBytes());
            
            Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
            cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);
            
            byte[] decrypted = cipher.doFinal(Base64.getDecoder().decode(encryptedPhone));
            return new String(decrypted, StandardCharsets.UTF_8);
        } catch (Exception e) {
            throw new RuntimeException("解密失败", e);
        }
    }
}
```

#### 2.3.2 数据脱敏
```java
@Component
public class DataMaskingService {
    
    // 手机号脱敏
    public String maskPhone(String phone) {
        if (phone == null || phone.length() != 11) {
            return phone;
        }
        return phone.substring(0, 3) + "****" + phone.substring(7);
    }
    
    // 身份证号脱敏
    public String maskIdCard(String idCard) {
        if (idCard == null || idCard.length() < 10) {
            return idCard;
        }
        return idCard.substring(0, 6) + "********" + idCard.substring(idCard.length() - 4);
    }
    
    // 姓名脱敏
    public String maskName(String name) {
        if (name == null || name.length() < 2) {
            return name;
        }
        StringBuilder masked = new StringBuilder(name.substring(0, 1));
        for (int i = 1; i < name.length(); i++) {
            masked.append("*");
        }
        return masked.toString();
    }
}
```

### 2.4 审计与日志增强

#### 2.4.1 API访问审计日志
```java
@Aspect
@Component
public class ApiAuditAspect {
    
    @Autowired
    private ApiAuditLogService apiAuditLogService;
    
    @Pointcut("@annotation(com.heikeji.common.annotation.LogAudit)")
    public void auditPointcut() {}
    
    @Around("auditPointcut()")
    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {
        // 获取请求信息
        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();
        
        // 构建审计日志
        ApiAuditLog log = new ApiAuditLog();
        log.setRequestUri(request.getRequestURI());
        log.setRequestMethod(request.getMethod());
        log.setClientIp(getClientIp(request));
        log.setRequestTime(new Date());
        log.setUsername(getCurrentUsername());
        
        // 执行目标方法
        Object result;
        try {
            result = joinPoint.proceed();
            log.setResponseStatus(200);
        } catch (Exception e) {
            log.setResponseStatus(500);
            log.setErrorMessage(e.getMessage());
            throw e; // 重新抛出异常
        } finally {
            log.setResponseTime(new Date());
            log.setExecutionTime(log.getResponseTime().getTime() - log.getRequestTime().getTime());
            
            // 异步保存审计日志
            CompletableFuture.runAsync(() -> {
                try {
                    apiAuditLogService.save(log);
                } catch (Exception e) {
                    // 记录保存失败日志
                }
            });
        }
        
        return result;
    }
}
```

## 3. 当前性能状况分析

### 3.1 现有性能优化措施

#### 3.1.1 缓存机制
- **Redis缓存**: 项目已集成Redis，配置了RedisTemplate用于数据缓存
- **会话管理**: 使用Redis存储会话信息和Token

#### 3.1.2 数据库优化
- **MyBatis-Plus**: 使用MyBatis-Plus框架的分页插件
- **延迟加载**: 数据库查询使用延迟加载机制

#### 3.1.3 请求处理
- **请求日志拦截器**: 记录请求响应时间，便于性能监控
- **统一响应格式**: 使用AppResponse统一响应格式

### 3.2 性能瓶颈分析

#### 3.2.1 数据库性能
- **缺少查询缓存**: 频繁执行的查询未实现多级缓存
- **分页查询优化不足**: 大数据量下的分页查询性能有待优化
- **事务管理不精细**: 部分事务粒度过大，影响并发性能

#### 3.2.2 应用性能
- **缺少请求缓存**: 对不变数据的重复请求未实现缓存
- **序列化/反序列化开销**: JSON序列化和反序列化可能成为性能瓶颈
- **缺少异步处理**: 部分耗时操作未使用异步处理

#### 3.2.3 资源利用
- **连接池配置**: 数据库连接池和HTTP连接池配置可能不够优化
- **内存管理**: 部分场景可能存在内存使用效率不高的问题

## 4. 性能优化建议

### 4.1 缓存优化策略

#### 4.1.1 多级缓存实现
```java
@Configuration
public class CacheConfig {
    
    @Bean
    public CacheManager cacheManager(RedisConnectionFactory factory) {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofMinutes(10)) // 默认缓存过期时间10分钟
                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer()))
                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer()));
        
        // 为不同缓存区域设置不同的过期时间
        Map<String, RedisCacheConfiguration> cacheConfigurations = new HashMap<>();
        cacheConfigurations.put("productCache", config.entryTtl(Duration.ofHours(1))); // 商品缓存1小时
        cacheConfigurations.put("categoryCache", config.entryTtl(Duration.ofHours(2))); // 分类缓存2小时
        cacheConfigurations.put("userCache", config.entryTtl(Duration.ofMinutes(30))); // 用户缓存30分钟
        
        return RedisCacheManager.builder(factory)
                .cacheDefaults(config)
                .withInitialCacheConfigurations(cacheConfigurations)
                .withCacheConfiguration("hotData", 
                        config.entryTtl(Duration.ofMinutes(5)).disableCachingNullValues())
                .build();
    }
}

@Service
public class ProductService {
    
    @Cacheable(value = "productCache", key = "#id")
    public Product getProductById(Long id) {
        // 数据库查询逻辑
        return productMapper.selectById(id);
    }
    
    @CacheEvict(value = "productCache", key = "#product.id")
    public void updateProduct(Product product) {
        // 更新逻辑
        productMapper.updateById(product);
    }
}
```

#### 4.1.2 本地缓存与分布式缓存结合
```java
@Component
public class CaffeineLocalCacheConfig {
    
    @Bean
    public Cache<String, Object> localCache() {
        return Caffeine.newBuilder()
                .maximumSize(1000) // 最大缓存项数
                .expireAfterWrite(5, TimeUnit.MINUTES) // 写入后过期时间
                .recordStats() // 记录统计信息
                .build();
    }
}

@Service
public class TwoLevelCacheService {
    
    @Autowired
    private Cache<String, Object> localCache;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    // 读取缓存（先查本地，再查Redis）
    public <T> T get(String key, Class<T> type) {
        // 1. 先查本地缓存
        Object value = localCache.getIfPresent(key);
        if (value != null) {
            return type.cast(value);
        }
        
        // 2. 再查Redis
        value = redisTemplate.opsForValue().get(key);
        if (value != null) {
            // 回填本地缓存
            localCache.put(key, value);
            return type.cast(value);
        }
        
        return null;
    }
    
    // 写入缓存
    public void put(String key, Object value, long expireTime, TimeUnit timeUnit) {
        // 1. 更新本地缓存
        localCache.put(key, value);
        
        // 2. 更新Redis
        redisTemplate.opsForValue().set(key, value, expireTime, timeUnit);
    }
    
    // 删除缓存
    public void evict(String key) {
        // 1. 删除本地缓存
        localCache.invalidate(key);
        
        // 2. 删除Redis缓存
        redisTemplate.delete(key);
    }
}
```

### 4.2 数据库性能优化

#### 4.2.1 优化数据库连接池
```yaml
# application.yml 中的连接池配置
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/heikeji_mall?useUnicode=true&characterEncoding=UTF-8&serverTimezone=Asia/Shanghai
    username: root
    password: password
    hikari:
      maximum-pool-size: 20                 # 最大连接数
      minimum-idle: 5                       # 最小空闲连接数
      connection-timeout: 30000             # 连接超时时间（毫秒）
      idle-timeout: 600000                  # 空闲连接超时时间（毫秒）
      max-lifetime: 1800000                 # 连接最大生命周期（毫秒）
      validation-timeout: 5000              # 连接验证超时时间（毫秒）
      leak-detection-threshold: 60000       # 连接泄漏检测阈值（毫秒）
```

#### 4.2.2 实现数据库读写分离
```java
@Configuration
public class DataSourceConfig {
    
    // 主数据源配置
    @Bean(name = "masterDataSource")
    @ConfigurationProperties(prefix = "spring.datasource.master")
    public DataSource masterDataSource() {
        return DataSourceBuilder.create().build();
    }
    
    // 从数据源配置
    @Bean(name = "slaveDataSource")
    @ConfigurationProperties(prefix = "spring.datasource.slave")
    public DataSource slaveDataSource() {
        return DataSourceBuilder.create().build();
    }
    
    // 动态数据源路由
    @Bean(name = "dynamicDataSource")
    @Primary
    public DataSource dynamicDataSource(@Qualifier("masterDataSource") DataSource masterDataSource, 
                                       @Qualifier("slaveDataSource") DataSource slaveDataSource) {
        DynamicRoutingDataSource routingDataSource = new DynamicRoutingDataSource();
        
        Map<Object, Object> targetDataSources = new HashMap<>();
        targetDataSources.put(DataSourceType.MASTER, masterDataSource);
        targetDataSources.put(DataSourceType.SLAVE, slaveDataSource);
        
        routingDataSource.setTargetDataSources(targetDataSources);
        routingDataSource.setDefaultTargetDataSource(masterDataSource);
        
        return routingDataSource;
    }
}

// 使用示例
@Service
public class ProductService {
    
    @Autowired
    private ProductMapper productMapper;
    
    @ReadDataSource  // 使用从库读取
    public List<Product> getProductList(Page page, ProductQuery query) {
        return productMapper.selectProductList(page, query);
    }
    
    @WriteDataSource // 使用主库写入
    public int createProduct(Product product) {
        return productMapper.insert(product);
    }
}
```

### 4.3 应用性能优化

#### 4.3.1 异步处理优化
```java
@Configuration
@EnableAsync
public class AsyncConfig {
    
    @Bean(name = "taskExecutor")
    public Executor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);                // 核心线程数
        executor.setMaxPoolSize(50);                 // 最大线程数
        executor.setQueueCapacity(100);              // 队列容量
        executor.setThreadNamePrefix("AsyncTask-");   // 线程名称前缀
        executor.setKeepAliveSeconds(60);            // 线程存活时间（秒）
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy()); // 拒绝策略
        executor.initialize();
        return executor;
    }
}

@Service
public class AsyncTaskService {
    
    @Async("taskExecutor")
    public CompletableFuture<Void> sendNotification(Long userId, String message) {
        // 异步发送通知
        // ...
        return CompletableFuture.completedFuture(null);
    }
    
    @Async("taskExecutor")
    public CompletableFuture<Void> recordUserBehavior(Long userId, String behaviorType, String target) {
        // 异步记录用户行为
        // ...
        return CompletableFuture.completedFuture(null);
    }
}
```

#### 4.3.2 响应压缩
```java
@Configuration
public class WebServerConfig {
    
    @Bean
    public ConfigurableServletWebServerFactory webServerFactory() {
        TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory();
        
        // 配置压缩
        factory.addConnectorCustomizers(connector -> {
            connector.setPort(8080);
            connector.addUpgradeProtocol(new Http2Protocol());
        });
        
        return factory;
    }
}

// 在application.yml中配置
server:
  compression:
    enabled: true
    mime-types: application/json,application/xml,text/html,text/xml,text/plain,text/css,application/javascript
    min-response-size: 1024
```

#### 4.3.3 优化序列化性能
```java
@Configuration
public class JacksonConfig {
    
    @Bean
    public ObjectMapper objectMapper() {
        ObjectMapper mapper = new ObjectMapper();
        
        // 优化Jackson配置
        mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL); // 不序列化null值
        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); // 忽略未知属性
        mapper.configure(MapperFeature.DEFAULT_VIEW_INCLUSION, true);
        mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); // 日期不使用时间戳
        
        // 配置日期格式
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        mapper.registerModule(new JavaTimeModule()
                .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(formatter))
                .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(formatter)));
        
        return mapper;
    }
}
```

### 4.4 JVM优化

#### 4.4.1 JVM参数优化建议
```
# JVM优化参数示例
JAVA_OPTS="-Xms4g -Xmx4g -XX:MetaspaceSize=256m -XX:MaxMetaspaceSize=512m -XX:+UseG1GC -XX:MaxGCPauseMillis=200 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/logs/heapdump.hprof -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:/logs/gc.log"

# 解释：
# -Xms4g -Xmx4g: 初始堆内存和最大堆内存设置为4GB，避免频繁调整堆大小
# -XX:MetaspaceSize=256m -XX:MaxMetaspaceSize=512m: 元空间初始和最大值
# -XX:+UseG1GC: 使用G1垃圾收集器
# -XX:MaxGCPauseMillis=200: 最大GC暂停时间目标为200ms
# -XX:+HeapDumpOnOutOfMemoryError: OOM时自动生成堆转储文件
# -XX:HeapDumpPath=/logs/heapdump.hprof: 堆转储文件路径
# -XX:+PrintGCDetails -XX:+PrintGCDateStamps: 打印GC详细信息和时间戳
# -Xloggc:/logs/gc.log: GC日志文件路径
```

## 5. 安全与性能监控系统

### 5.1 安全监控方案

#### 5.1.1 集成Spring Security监控
```java
@Component
public class SecurityMetricsCollector implements ApplicationListener<AbstractAuthenticationEvent> {
    
    @Autowired
    private MeterRegistry meterRegistry;
    
    @Override
    public void onApplicationEvent(AbstractAuthenticationEvent event) {
        if (event instanceof AuthenticationSuccessEvent) {
            // 记录成功登录
            meterRegistry.counter("security.authentication.success").increment();
        } else if (event instanceof AbstractAuthenticationFailureEvent) {
            // 记录失败登录
            meterRegistry.counter("security.authentication.failure").increment();
            
            // 记录具体失败原因
            AbstractAuthenticationFailureEvent failureEvent = (AbstractAuthenticationFailureEvent) event;
            String exceptionType = failureEvent.getException().getClass().getSimpleName();
            meterRegistry.counter("security.authentication.failure", "exception", exceptionType).increment();
        }
    }
}
```

#### 5.1.2 异常行为监控
```java
@Service
public class AbnormalBehaviorDetector {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    // 检测登录失败次数
    public boolean isLoginFailureExceeded(String username) {
        String key = "login_failure:" + username;
        Long count = redisTemplate.opsForValue().increment(key, 1);
        
        // 第一次登录失败，设置过期时间
        if (count == 1) {
            redisTemplate.expire(key, 1, TimeUnit.HOURS);
        }
        
        // 5次失败后触发告警
        if (count >= 5) {
            // 发送告警通知
            sendAlert("登录失败次数过多", "用户名: " + username + ", 失败次数: " + count);
            return true;
        }
        
        return false;
    }
    
    // 检测异常IP访问
    public boolean isAbnormalIpAccess(String ip) {
        String key = "ip_access:" + ip;
        Long count = redisTemplate.opsForValue().increment(key, 1);
        
        // 第一次访问，设置过期时间
        if (count == 1) {
            redisTemplate.expire(key, 1, TimeUnit.MINUTES);
        }
        
        // 每分钟超过100次请求，认为异常
        if (count >= 100) {
            sendAlert("IP访问频率异常", "IP: " + ip + ", 每分钟请求数: " + count);
            return true;
        }
        
        return false;
    }
    
    private void sendAlert(String title, String content) {
        // 发送告警通知
        // 可以通过邮件、短信或企业微信等方式
    }
}
```

### 5.2 性能监控方案

#### 5.2.1 集成Prometheus + Grafana
```xml
<!-- 添加依赖 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-registry-prometheus</artifactId>
</dependency>
```

```yaml
# application.yml 配置
management:
  endpoints:
    web:
      exposure:
        include: health,info,prometheus,metrics
  metrics:
    export:
      prometheus:
        enabled: true
    tags:
      application: ${spring.application.name}
  endpoint:
    health:
      show-details: always
```

#### 5.2.2 自定义性能指标
```java
@Component
public class CustomMetricsCollector {
    
    private final MeterRegistry meterRegistry;
    
    @Autowired
    public CustomMetricsCollector(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        
        // 注册自定义指标
        registerCustomGauges();
    }
    
    private void registerCustomGauges() {
        // 缓存命中率指标
        Gauge.builder("cache.hit.rate", this, CustomMetricsCollector::calculateCacheHitRate)
                .description("缓存命中率")
                .register(meterRegistry);
        
        // 活跃用户数指标
        Gauge.builder("users.active", this, CustomMetricsCollector::getActiveUserCount)
                .description("活跃用户数")
                .register(meterRegistry);
    }
    
    private double calculateCacheHitRate() {
        // 计算缓存命中率的逻辑
        return 0.8; // 示例值
    }
    
    private int getActiveUserCount() {
        // 获取活跃用户数的逻辑
        return 100; // 示例值
    }
    
    // 记录业务指标
    public void recordOrderMetrics(double amount) {
        // 记录订单金额分布
        meterRegistry.distributionSummary("order.amount").record(amount);
        
        // 记录订单计数
        meterRegistry.counter("order.count").increment();
    }
}
```

## 6. 实施计划

### 6.1 第一阶段：基础安全加固（2周）
- 完善JWT密钥管理，从环境变量获取
- 实现API速率限制
- 优化CORS配置，限制允许的域名
- 添加安全响应头
- 实现基础的API访问审计日志

### 6.2 第二阶段：数据安全增强（2周）
- 敏感数据加密存储
- 实现数据脱敏
- 增强密码策略
- 完善权限控制粒度
- 实现Token黑名单机制

### 6.3 第三阶段：性能基础优化（2周）
- 配置多级缓存
- 优化数据库连接池
- 优化JVM参数
- 实现响应压缩
- 优化序列化性能

### 6.4 第四阶段：高级性能优化（3周）
- 实现数据库读写分离
- 添加本地缓存与分布式缓存结合
- 实现异步处理框架
- 优化大数据量查询
- 完善性能监控指标

### 6.5 第五阶段：监控与告警系统（2周）
- 集成Prometheus + Grafana
- 配置安全监控告警
- 配置性能监控告警
- 实现异常行为检测
- 完善运维监控面板

## 7. 风险与挑战

### 7.1 安全加固风险
- **兼容性问题**: 安全加固可能影响现有功能，特别是CORS和请求限制
- **性能影响**: 增加的安全检查可能对性能造成一定影响
- **运维复杂度**: 安全配置增加会提高运维复杂度
- **误报风险**: 异常行为检测可能产生误报

### 7.2 性能优化风险
- **缓存一致性**: 多级缓存可能导致数据不一致
- **代码复杂度**: 读写分离和异步处理增加代码复杂度
- **故障排查难度**: 分布式系统故障排查难度增加
- **资源消耗**: 缓存和连接池配置不当可能导致资源浪费

### 7.3 应对策略
- **分阶段实施**: 每个优化措施独立实施，便于回滚
- **全面测试**: 每个阶段实施后进行全面测试
- **灰度发布**: 关键优化措施采用灰度发布策略
- **监控到位**: 实时监控系统性能和安全状态
- **回滚方案**: 为每个优化措施制定详细的回滚方案

## 8. 预期收益

### 8.1 安全收益
- **风险降低**: 显著降低数据泄露和未授权访问风险
- **合规性提升**: 满足基本的安全合规要求
- **攻击防御**: 提高对常见攻击的防御能力
- **安全监控**: 实时监控系统安全状态，及时发现异常

### 8.2 性能收益
- **响应时间提升**: 页面加载和API响应时间显著减少
- **并发处理能力**: 系统并发处理能力提升5-10倍
- **资源利用率**: 服务器资源利用率更加合理
- **用户体验**: 整体用户体验得到改善

### 8.3 运维收益
- **可观测性**: 系统状态更加透明，便于监控
- **问题定位**: 问题定位更加快速和准确
- **运维效率**: 自动化监控减少人工运维成本
- **系统稳定性**: 系统整体稳定性提升

---

本方案旨在全面提升黑科易购项目的安全性和性能，需要开发团队和运维团队密切配合，按照计划分阶段实施。实施过程中要注重测试和监控，确保每个阶段的变更都能达到预期效果。