# 黑科易购项目数据库设计和性能优化方案

## 1. 当前数据库结构分析

### 1.1 整体架构概述
- **数据库类型**: MySQL 8.0.33
- **存储引擎**: InnoDB (默认)
- **字符集**: UTF-8mb4
- **主要业务模块**: 
  - 用户模块
  - 商品模块
  - 订单模块
  - 支付模块
  - 配送模块
  - 校园服务模块
  - 外卖服务模块

### 1.2 核心表结构分析

#### 1.2.1 用户相关表
- **user**: 用户基本信息表
  - 关键字段: id, student_no, nickname, phone, balance
  - 索引: PRIMARY KEY(id), UNIQUE KEY(student_no), KEY(phone)
  - 数据量预估: 中等至大型
  - 更新频率: 中等

- **user_auth**: 用户认证表(微信登录)
  - 关键字段: id, user_id, open_id, union_id
  - 索引: PRIMARY KEY(id), UNIQUE KEY(open_id), KEY(user_id)
  - 数据量预估: 与用户表相当
  - 更新频率: 低

- **address**: 收货地址表
  - 关键字段: id, user_id, receiver_name, receiver_phone, campus_area, building, room
  - 索引: PRIMARY KEY(id), KEY(user_id)
  - 数据量预估: 中等
  - 更新频率: 低

#### 1.2.2 商品相关表
- **merchant**: 商家表
  - 关键字段: id, name, logo, description, status
  - 索引: PRIMARY KEY(id)
  - 数据量预估: 小型
  - 更新频率: 低

- **category**: 商品分类表
  - 关键字段: id, name, parent_id, sort_order
  - 索引: PRIMARY KEY(id), KEY(parent_id)
  - 数据量预估: 小型
  - 更新频率: 低

- **product**: 商品表
  - 关键字段: id, merchant_id, category_id, name, price, stock, sales, status
  - 索引: PRIMARY KEY(id), KEY(merchant_id), KEY(category_id)
  - 数据量预估: 大型
  - 更新频率: 中等

#### 1.2.3 订单相关表
- **order**: 订单主表
  - 关键字段: id, order_no, user_id, merchant_id, order_type, total_amount, status
  - 索引: PRIMARY KEY(id), UNIQUE KEY(order_no), KEY(user_id), KEY(merchant_id), KEY(status)
  - 数据量预估: 大型
  - 更新频率: 高

- **order_item**: 订单商品明细表
  - 关键字段: id, order_id, product_id, product_name, product_price, quantity
  - 索引: PRIMARY KEY(id), KEY(order_id)
  - 数据量预估: 大型
  - 更新频率: 高

#### 1.2.4 其他核心表
- **delivery_request**: 跑腿需求表
- **takeout_order**: 外卖订单表
- **delivery_locker**: 外卖柜表
- **payment**: 支付记录表
- **delivery_person**: 跑腿员表
- **campus_info**: 校园信息表
- **product_view_history**: 用户浏览历史表
- **cart**: 购物车表

### 1.3 当前索引优化措施

项目已实施的索引优化包括：
- 用户表相关索引：status, create_time, is_verified
- 商品表相关索引：status, sales, create_time, price, merchant_id+category_id等复合索引
- 订单表相关索引：user_id, status, create_time, user_id+status, order_type等
- 支付表、购物车表、配送表等都建立了相应的索引

### 1.4 性能监控现状

当前已实现的数据库性能监控包括：
- 数据库连接数监控
- 慢查询统计
- 表大小统计和更新频率分析
- 索引效率分析
- 业务指标监控（用户活跃度、订单活跃度等）
- 系统资源使用情况监控（InnoDB缓冲池、查询缓存等）

## 2. 数据库设计优化建议

### 2.1 表结构优化

#### 2.1.1 用户表优化
- **添加冗余字段**: 在用户表中添加last_login_time, login_count等字段，便于用户活跃度统计
- **用户余额字段优化**: 考虑将balance字段从user表中分离到独立的user_account表中，减少user表的更新频率
- **添加索引**: 为nickname添加全文索引，支持模糊搜索

```sql
-- 创建用户账户表
CREATE TABLE `user_account` (
  `id` BIGINT(20) NOT NULL AUTO_INCREMENT,
  `user_id` BIGINT(20) NOT NULL COMMENT '用户ID',
  `balance` DECIMAL(10,2) DEFAULT 0.00 COMMENT '账户余额',
  `frozen_balance` DECIMAL(10,2) DEFAULT 0.00 COMMENT '冻结余额',
  `update_time` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_user_id` (`user_id`)
) ENGINE=InnoDB COMMENT='用户账户表';

-- 为用户表添加字段
ALTER TABLE `user` ADD COLUMN `last_login_time` DATETIME DEFAULT NULL COMMENT '最后登录时间';
ALTER TABLE `user` ADD COLUMN `login_count` INT(11) DEFAULT 0 COMMENT '登录次数';
ALTER TABLE `user` ADD FULLTEXT INDEX `idx_nickname` (`nickname`) COMMENT '昵称全文索引';
```

#### 2.1.2 商品表优化
- **商品规格分离**: 创建product_sku表，将商品规格和价格信息分离
- **商品详情分离**: 将商品详情字段移至独立的product_detail表，减少product表的大小
- **添加冗余字段**: 在product表添加一些常用统计字段，如comment_count

```sql
-- 创建商品规格表
CREATE TABLE `product_sku` (
  `id` BIGINT(20) NOT NULL AUTO_INCREMENT,
  `product_id` BIGINT(20) NOT NULL COMMENT '商品ID',
  `spec_name` VARCHAR(100) DEFAULT NULL COMMENT '规格名称',
  `spec_value` VARCHAR(100) DEFAULT NULL COMMENT '规格值',
  `price` DECIMAL(10,2) NOT NULL COMMENT '价格',
  `stock` INT(11) DEFAULT 0 COMMENT '库存',
  `sales` INT(11) DEFAULT 0 COMMENT '销量',
  `status` TINYINT(1) DEFAULT 0 COMMENT '状态',
  `create_time` DATETIME DEFAULT CURRENT_TIMESTAMP,
  `update_time` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `idx_product_id` (`product_id`)
) ENGINE=InnoDB COMMENT='商品规格表';

-- 创建商品详情表
CREATE TABLE `product_detail` (
  `id` BIGINT(20) NOT NULL AUTO_INCREMENT,
  `product_id` BIGINT(20) NOT NULL COMMENT '商品ID',
  `detail` TEXT COMMENT '商品详情',
  `package_info` TEXT COMMENT '包装信息',
  `update_time` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_product_id` (`product_id`)
) ENGINE=InnoDB COMMENT='商品详情表';

-- 为商品表添加字段
ALTER TABLE `product` ADD COLUMN `comment_count` INT(11) DEFAULT 0 COMMENT '评论数';
ALTER TABLE `product` DROP COLUMN `detail`; -- 将商品详情移至product_detail表
```

#### 2.1.3 订单表优化
- **订单状态变更记录**: 创建order_status_history表，记录订单状态变更历史
- **订单分表策略**: 考虑按时间范围进行订单表分区或分表
- **冗余字段优化**: 优化订单表中的冗余字段存储

```sql
-- 创建订单状态历史表
CREATE TABLE `order_status_history` (
  `id` BIGINT(20) NOT NULL AUTO_INCREMENT,
  `order_id` BIGINT(20) NOT NULL COMMENT '订单ID',
  `order_no` VARCHAR(32) NOT NULL COMMENT '订单号',
  `old_status` TINYINT(1) DEFAULT NULL COMMENT '原状态',
  `new_status` TINYINT(1) NOT NULL COMMENT '新状态',
  `operator_type` TINYINT(1) DEFAULT 0 COMMENT '操作类型：0-系统，1-用户，2-管理员',
  `operator_id` BIGINT(20) DEFAULT NULL COMMENT '操作者ID',
  `remark` VARCHAR(200) DEFAULT NULL COMMENT '备注',
  `create_time` DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '操作时间',
  PRIMARY KEY (`id`),
  KEY `idx_order_id` (`order_id`),
  KEY `idx_order_no` (`order_no`),
  KEY `idx_create_time` (`create_time`)
) ENGINE=InnoDB COMMENT='订单状态历史表';
```

### 2.2 数据模型优化

#### 2.2.1 引入时序数据模型
- **用户行为日志**: 创建统一的用户行为日志表，支持按时间段分区
- **数据过期策略**: 定义数据过期策略，定期清理不再需要的历史数据

```sql
-- 创建用户行为日志表
CREATE TABLE `user_behavior_log` (
  `id` BIGINT(20) NOT NULL AUTO_INCREMENT,
  `user_id` BIGINT(20) NOT NULL COMMENT '用户ID',
  `behavior_type` TINYINT(1) NOT NULL COMMENT '行为类型：1-浏览，2-点击，3-加购，4-下单',
  `target_id` BIGINT(20) DEFAULT NULL COMMENT '目标ID（商品ID/订单ID等）',
  `target_type` TINYINT(1) DEFAULT NULL COMMENT '目标类型：1-商品，2-商家，3-分类',
  `ip_address` VARCHAR(50) DEFAULT NULL COMMENT 'IP地址',
  `user_agent` VARCHAR(255) DEFAULT NULL COMMENT '用户代理',
  `behavior_time` DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '行为时间',
  PRIMARY KEY (`id`),
  KEY `idx_user_id` (`user_id`),
  KEY `idx_behavior_type` (`behavior_type`),
  KEY `idx_target` (`target_type`, `target_id`),
  KEY `idx_behavior_time` (`behavior_time`)
) ENGINE=InnoDB COMMENT='用户行为日志表';

-- 按月份分区示例
ALTER TABLE `user_behavior_log` PARTITION BY RANGE (TO_DAYS(behavior_time)) (
    PARTITION p202401 VALUES LESS THAN (TO_DAYS('2024-02-01')),
    PARTITION p202402 VALUES LESS THAN (TO_DAYS('2024-03-01')),
    PARTITION p202403 VALUES LESS THAN (TO_DAYS('2024-04-01')),
    PARTITION pfuture VALUES LESS THAN MAXVALUE
);
```

#### 2.2.2 引入消息队列模型
- **延迟任务表**: 创建延迟任务表，处理订单超时等延迟任务
- **事件记录表**: 记录业务事件，支持事件溯源和异步处理

```sql
-- 创建延迟任务表
CREATE TABLE `delayed_task` (
  `id` BIGINT(20) NOT NULL AUTO_INCREMENT,
  `task_type` VARCHAR(50) NOT NULL COMMENT '任务类型',
  `task_data` JSON DEFAULT NULL COMMENT '任务数据',
  `execute_time` DATETIME NOT NULL COMMENT '执行时间',
  `status` TINYINT(1) DEFAULT 0 COMMENT '状态：0-待执行，1-执行中，2-已完成，3-执行失败',
  `retry_count` INT(11) DEFAULT 0 COMMENT '重试次数',
  `create_time` DATETIME DEFAULT CURRENT_TIMESTAMP,
  `update_time` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `idx_execute_time_status` (`execute_time`, `status`)
) ENGINE=InnoDB COMMENT='延迟任务表';
```

## 3. 索引优化策略

### 3.1 现有索引优化

#### 3.1.1 优化现有索引
- **移除无效索引**: 移除未使用或重复的索引
- **优化索引顺序**: 调整复合索引的字段顺序，将选择性高的字段放在前面
- **减少冗余索引**: 避免创建功能重叠的索引

```sql
-- 移除未使用的索引（示例）
ALTER TABLE `user` DROP INDEX IF EXISTS `idx_is_verified`; -- 如果验证发现此索引未被使用

-- 优化复合索引顺序
ALTER TABLE `order` DROP INDEX IF EXISTS `idx_user_status`;
ALTER TABLE `order` ADD INDEX `idx_status_user` (`status`, `user_id`) COMMENT '按状态查询用户订单优化';
```

#### 3.1.2 添加缺失索引
- **针对高频查询场景**: 添加必要的索引支持高频查询
- **支持排序和分组**: 为经常排序和分组的字段添加索引
- **外键索引**: 确保所有外键都有合适的索引

```sql
-- 为商品表添加复合索引，支持常用查询场景
ALTER TABLE `product` ADD INDEX `idx_status_merchant` (`status`, `merchant_id`) COMMENT '查询商家上架商品';

-- 为订单表添加支持排序的索引
ALTER TABLE `order` ADD INDEX `idx_create_time_desc` (`create_time` DESC) COMMENT '按创建时间倒序查询';

-- 为支付表添加外键索引
ALTER TABLE `payment` ADD INDEX `idx_order_id_status` (`order_id`, `status`) COMMENT '订单支付状态查询';
```

### 3.2 高级索引技术

#### 3.2.1 覆盖索引
- **创建覆盖索引**: 包含查询所需的所有字段，避免回表
- **索引字段顺序**: 根据查询频率和顺序优化索引字段顺序

```sql
-- 创建覆盖索引，避免回表（示例：商品列表页查询）
ALTER TABLE `product` ADD INDEX `idx_list_query` (`status`, `category_id`, `sales` DESC, `price`, `name`) COMMENT '商品列表查询覆盖索引';
```

#### 3.2.2 函数索引
- **使用函数索引**: 为常用的函数表达式创建索引
- **虚拟列索引**: 对于复杂表达式，可以考虑使用虚拟列

```sql
-- 创建函数索引示例（MySQL 8.0+）
CREATE INDEX idx_nickname_upper ON `user` ((UPPER(nickname)));

-- 创建虚拟列并添加索引
ALTER TABLE `order` ADD COLUMN `create_date` DATE GENERATED ALWAYS AS (DATE(create_time)) STORED;
ALTER TABLE `order` ADD INDEX `idx_create_date` (`create_date`);
```

#### 3.2.3 全文索引
- **添加全文索引**: 为需要模糊搜索的字段添加全文索引
- **优化全文搜索**: 配置适当的全文搜索参数

```sql
-- 为商品名称添加全文索引
ALTER TABLE `product` ADD FULLTEXT INDEX `idx_name_fulltext` (`name`, `subtitle`) COMMENT '商品名称和副标题全文索引';

-- 为商家名称添加全文索引
ALTER TABLE `merchant` ADD FULLTEXT INDEX `idx_name_desc_fulltext` (`name`, `description`) COMMENT '商家名称和描述全文索引';
```

## 4. 查询性能优化

### 4.1 SQL优化策略

#### 4.1.1 慢查询优化
- **识别慢查询**: 开启慢查询日志，识别慢查询SQL
- **分析执行计划**: 使用EXPLAIN分析查询执行计划
- **优化查询语句**: 重写复杂查询，避免全表扫描

```sql
-- 优化前：可能导致全表扫描的查询
SELECT * FROM `product` WHERE name LIKE '%手机%';

-- 优化后：使用全文索引
SELECT * FROM `product` WHERE MATCH(name, subtitle) AGAINST('手机' IN NATURAL LANGUAGE MODE);

-- 优化前：复杂的多表连接查询
SELECT o.*, p.name, p.price FROM `order` o JOIN `order_item` oi ON o.id = oi.order_id JOIN `product` p ON oi.product_id = p.id WHERE o.user_id = 123;

-- 优化后：分步查询或优化连接顺序
SELECT o.* FROM `order` o WHERE o.user_id = 123;
-- 然后通过应用程序查询相关商品信息
```

#### 4.1.2 批量操作优化
- **使用批量插入**: 合并多个INSERT语句为一个
- **批量更新**: 使用CASE WHEN进行批量更新
- **批量删除**: 使用IN子句或临时表进行批量删除

```sql
-- 批量插入示例
INSERT INTO `order_item` (order_id, product_id, quantity) VALUES
(1, 1001, 2),
(1, 1002, 1),
(2, 1003, 3);

-- 批量更新示例
UPDATE `product`
SET stock = CASE
    WHEN id = 1001 THEN stock - 2
    WHEN id = 1002 THEN stock - 1
    WHEN id = 1003 THEN stock - 3
END
WHERE id IN (1001, 1002, 1003);
```

### 4.2 分页查询优化

#### 4.2.1 优化深度分页
- **使用游标的分页**: 基于上一页最后一条记录的ID进行分页
- **使用延迟关联**: 先获取ID列表，再关联获取详情

```sql
-- 优化前：传统分页，数据量大时性能较差
SELECT * FROM `product` WHERE status = 0 ORDER BY sales DESC LIMIT 10000, 10;

-- 优化后：使用ID游标分页
SELECT * FROM `product` WHERE status = 0 AND id > 10000 ORDER BY id LIMIT 10;

-- 优化后：使用延迟关联
SELECT p.* FROM `product` p
JOIN (SELECT id FROM `product` WHERE status = 0 ORDER BY sales DESC LIMIT 10000, 10) p_ids
ON p.id = p_ids.id;
```

### 4.3 读写分离策略

#### 4.3.1 数据库读写分离
- **主从复制**: 配置MySQL主从复制
- **读写分离实现**: 应用层实现读写分离逻辑
- **动态数据源**: 使用Spring的AbstractRoutingDataSource实现动态数据源

```java
// 伪代码示例：动态数据源配置
public class DynamicDataSource extends AbstractRoutingDataSource {
    @Override
    protected Object determineCurrentLookupKey() {
        return DataSourceContextHolder.getDataSourceType();
    }
}

// 在Service层控制数据源选择
@Service
public class ProductService {
    @Transactional(readOnly = true)
    public List<Product> getProductList() {
        DataSourceContextHolder.setDataSourceType(DataSourceType.SLAVE);
        return productMapper.selectList(null);
    }
    
    @Transactional
    public void createProduct(Product product) {
        DataSourceContextHolder.setDataSourceType(DataSourceType.MASTER);
        productMapper.insert(product);
    }
}
```

## 5. 数据库扩展方案

### 5.1 垂直扩展

#### 5.1.1 表拆分
- **按功能模块拆分**: 将不同功能模块的数据分散到不同的数据库
- **表垂直拆分**: 将大表拆分为多个小表，按列拆分

**拆分建议：**
- 商品相关表：商品基本信息、商品详情、商品规格拆分为独立表
- 订单相关表：订单主表、订单商品明细、订单状态历史拆分为独立表
- 用户相关表：用户基本信息、用户认证信息、用户账户信息拆分为独立表

#### 5.1.2 分库策略
- **功能分库**: 按业务功能将数据分散到不同的数据库
- **分库示例**:
  - user_db: 用户相关数据
  - product_db: 商品相关数据
  - order_db: 订单相关数据
  - payment_db: 支付相关数据
  - campus_db: 校园服务相关数据

### 5.2 水平扩展

#### 5.2.1 水平分表
- **时间范围分表**: 按时间范围将数据分散到不同的表
- **哈希分表**: 按ID或其他关键字段哈希分散到不同的表
- **分表示例**:
  - order_202401, order_202402, ... (按月份分表)
  - user_0, user_1, user_2, ... (按用户ID哈希分表)

#### 5.2.2 分区表
- **范围分区**: 按数值范围对表进行分区
- **列表分区**: 按枚举值进行分区
- **哈希分区**: 按哈希函数的结果进行分区
- **子分区**: 在分区的基础上进行子分区

```sql
-- 订单表按月份范围分区示例
ALTER TABLE `order` PARTITION BY RANGE (TO_DAYS(create_time)) (
    PARTITION p202401 VALUES LESS THAN (TO_DAYS('2024-02-01')),
    PARTITION p202402 VALUES LESS THAN (TO_DAYS('2024-03-01')),
    PARTITION p202403 VALUES LESS THAN (TO_DAYS('2024-04-01')),
    PARTITION p202404 VALUES LESS THAN (TO_DAYS('2024-05-01')),
    PARTITION pfuture VALUES LESS THAN MAXVALUE
);

-- 用户表按ID哈希分区示例
ALTER TABLE `user` PARTITION BY HASH (id % 8) (
    PARTITION p0,
    PARTITION p1,
    PARTITION p2,
    PARTITION p3,
    PARTITION p4,
    PARTITION p5,
    PARTITION p6,
    PARTITION p7
);
```

### 5.3 引入NoSQL数据库

#### 5.3.1 Redis缓存
- **热点数据缓存**: 将频繁访问的数据缓存到Redis
- **会话管理**: 使用Redis管理用户会话
- **分布式锁**: 使用Redis实现分布式锁
- **消息队列**: 使用Redis的List结构实现简单的消息队列

#### 5.3.2 Elasticsearch搜索
- **全文搜索引擎**: 引入Elasticsearch处理复杂的全文搜索
- **日志分析**: 使用Elasticsearch存储和分析系统日志
- **数据同步策略**: 实现MySQL到Elasticsearch的数据同步

```sql
-- 创建数据同步触发器示例（MySQL到Elasticsearch）
DELIMITER //
CREATE TRIGGER product_ai AFTER INSERT ON product FOR EACH ROW
BEGIN
    -- 调用外部同步服务的存储过程
    CALL sync_product_to_elasticsearch(NEW.id, 'INSERT');
END //
DELIMITER ;
```

## 6. 数据库备份与恢复策略

### 6.1 备份策略

#### 6.1.1 全量备份
- **备份频率**: 每天凌晨进行一次全量备份
- **备份工具**: 使用mysqldump或XtraBackup
- **备份存储**: 备份文件存储到独立的存储系统
- **备份验证**: 定期验证备份文件的完整性

```bash
# 使用mysqldump进行全量备份
mysqldump -u root -p --single-transaction --routines --triggers --events --all-databases > backup_$(date +%Y%m%d).sql

# 使用XtraBackup进行物理备份
xtrabackup --backup --target-dir=/backup/full_$(date +%Y%m%d)
```

#### 6.1.2 增量备份
- **备份频率**: 每小时进行一次增量备份
- **备份工具**: 使用XtraBackup进行增量备份
- **备份链**: 基于全量备份创建增量备份链

```bash
# 创建增量备份（基于前一天的全量备份）
xtrabackup --backup --target-dir=/backup/inc_$(date +%Y%m%d_%H%M) --incremental-basedir=/backup/full_$(date +%Y%m%d)
```

### 6.2 恢复策略

#### 6.2.1 恢复流程
- **制定恢复计划**: 明确恢复步骤和责任人
- **恢复验证**: 恢复后进行数据验证
- **定期演练**: 定期进行恢复演练，确保流程有效

#### 6.2.2 不同场景的恢复策略
- **全量恢复**: 恢复到最近的全量备份点
- **增量恢复**: 先恢复全量备份，再应用增量备份
- **时间点恢复**: 使用二进制日志进行时间点恢复

```bash
# 全量恢复示例
mysql -u root -p < backup_20240101.sql

# 使用二进制日志进行时间点恢复
mysqlbinlog --start-datetime="2024-01-01 10:00:00" --stop-datetime="2024-01-01 11:00:00" /var/lib/mysql/mysql-bin.000001 | mysql -u root -p
```

## 7. 数据库监控与维护计划

### 7.1 性能监控

#### 7.1.1 监控指标
- **资源使用**: CPU、内存、磁盘I/O、网络
- **数据库指标**: 连接数、慢查询数、缓存命中率
- **表和索引**: 表大小、索引使用情况
- **事务**: 活跃事务数、锁等待情况

#### 7.1.2 监控工具
- **自建监控**: 基于现有的performance_monitor.sql脚本扩展
- **专业工具**: 引入Prometheus + Grafana进行监控
- **告警机制**: 设置关键指标的告警阈值

```sql
-- 扩展性能监控脚本 - 监控活跃事务
SELECT 
    @check_time AS check_time,
    '事务监控' AS section,
    '活跃事务数' AS metric,
    COUNT(*) AS value,
    CASE 
        WHEN COUNT(*) > 50 THEN 'WARNING'
        WHEN COUNT(*) > 20 THEN 'NORMAL'
        ELSE 'GOOD'
    END AS status
FROM information_schema.INNODB_TRX;

-- 监控锁等待情况
SELECT 
    @check_time AS check_time,
    '锁监控' AS section,
    '锁等待数' AS metric,
    COUNT(*) AS value,
    CASE 
        WHEN COUNT(*) > 10 THEN 'WARNING'
        WHEN COUNT(*) > 5 THEN 'NORMAL'
        ELSE 'GOOD'
    END AS status
FROM information_schema.INNODB_LOCK_WAITS;
```

### 7.2 定期维护任务

#### 7.2.1 日常维护
- **表优化**: 定期执行OPTIMIZE TABLE优化表空间
- **索引重建**: 定期重建碎片化严重的索引
- **统计信息更新**: 更新表的统计信息

```sql
-- 优化表空间
OPTIMIZE TABLE `order`, `order_item`, `product`;

-- 更新统计信息
ANALYZE TABLE `user`, `order`, `product`, `merchant`;
```

#### 7.2.2 数据清理
- **历史数据归档**: 将历史数据归档到归档表
- **临时表清理**: 定期清理临时表和会话数据
- **日志清理**: 定期清理二进制日志和慢查询日志

```sql
-- 归档历史订单数据（示例）
CREATE TABLE IF NOT EXISTS `order_history_2023` LIKE `order`;
INSERT INTO `order_history_2023` SELECT * FROM `order` WHERE create_time < '2024-01-01';
DELETE FROM `order` WHERE create_time < '2024-01-01';

-- 清理超过30天的用户行为日志
DELETE FROM `user_behavior_log` WHERE behavior_time < DATE_SUB(NOW(), INTERVAL 30 DAY);
```

## 8. 实施计划

### 8.1 第一阶段：评估与准备（1周）
- 详细评估当前数据库性能状况
- 分析慢查询日志，识别性能瓶颈
- 准备测试环境
- 制定详细的实施计划

### 8.2 第二阶段：基础优化（2周）
- 实施表结构优化
- 优化现有索引
- 添加缺失索引
- 优化常用SQL查询

### 8.3 第三阶段：高级优化（3周）
- 实施读写分离
- 配置Redis缓存
- 引入Elasticsearch搜索
- 实现数据同步机制

### 8.4 第四阶段：扩展实施（4周）
- 实施分库分表策略
- 创建分区表
- 实现动态数据源切换
- 配置数据归档策略

### 8.5 第五阶段：监控与维护（持续）
- 部署监控系统
- 配置告警机制
- 制定定期维护计划
- 定期性能评估和优化

## 9. 风险与挑战

### 9.1 实施风险
- **数据一致性**: 分库分表可能引入数据一致性挑战
- **应用适配**: 现有应用需要适配新的数据库架构
- **性能退化**: 某些场景下性能可能出现短期退化
- **运维复杂度**: 运维工作复杂度增加

### 9.2 应对策略
- **分阶段实施**: 逐步实施，每步验证效果
- **完善测试**: 充分测试，确保功能正常
- **回滚机制**: 准备详细的回滚方案
- **培训团队**: 培训开发和运维团队

## 10. 预期收益

### 10.1 性能提升
- 系统响应时间显著减少
- 并发处理能力大幅提升
- 系统稳定性增强

### 10.2 可扩展性增强
- 系统支持更大规模的数据
- 支持更多用户同时访问
- 为未来功能扩展奠定基础

### 10.3 维护成本降低
- 日常维护工作更加高效
- 故障排查更加容易
- 系统管理更加规范

---

本方案旨在优化黑科易购项目的数据库设计和性能，提升系统的整体性能和可扩展性。实施过程中需要团队密切配合，按照计划分阶段推进，确保项目质量和进度。